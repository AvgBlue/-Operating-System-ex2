#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdbool.h>
#include <string.h>
#include <stdarg.h>
#include <dirent.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <libgen.h>// basename

#define EXIT_EXECVP_FAILED 99
#define MAX_SIZE 150
#define MAX_STRING_SIZE 150
#define CALCULATE_ELAPSED_TIME(start_time, end_time) \
    ((end_time.tv_sec - start_time.tv_sec) + (end_time.tv_usec - start_time.tv_usec) / 1000000.0)

#define EXECUTION_SUCCESSFUL 0
#define EXECUTION_TIMED_OUT 1
#define EXECUTION_ERROR -1



void addResultToFile(int result_fd,int grade, const char *name)
{
    const char *category;
    switch (grade) {
    case 0:
        category = "NO_C_FILE";
        break;
    case 10:
        category = "Compilation_Error";
        break;
    case 20:
        category = "TIMEOUT";
        break;
    case 50:
        category = "Wrong_output";
        break;
    case 75:
        category = "Similar_output";
        break;
    case 100:
        category = "EXCELLENT";
        break;
    default:
        return; // Invalid number, do nothing
    }
    char result[MAX_STRING_SIZE];
    int length = snprintf(result, MAX_STRING_SIZE, "%s,%d,%s\n", name, grade, category);

    if (write(result_fd, result, length) == -1)
    {
        perror("Error writing to file");
    }
}

void compileCFile(char path[MAX_STRING_SIZE], char outPutFileName[MAX_STRING_SIZE])
{

    // Open the compilation error file for writing
    int error_fd = open("compeionError", O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    if (error_fd == -1)
    {
        perror("open");
        return;
    }
    // Fork a child process
    pid_t pidfork = fork();
    if (pidfork == -1)
    {
        // Fork failed
        perror("fork failed");
        return;
    }
    else if (pidfork == 0)
    {
        // Child process
        // Redirect standard error to the error file
        dup2(error_fd, STDERR_FILENO);
        // Prepare arguments for gcc command
        char *args[] = {"gcc", "-o", outPutFileName, path, NULL};
        // Execute the gcc command with arguments
        execvp(args[0], args);
        // Print error message if execvp fails
        perror("execvp failed");
        // Exit child process with failure status
        exit(EXIT_EXECVP_FAILED);
    }
    // Parent process
    int status;
    // Wait for child process to complete
    wait(&status);
    close(error_fd);
    if (unlink("compeionError") == -1)
    {
        perror("unlink failed");
    }
}

int executeFileWithFDs(char path[MAX_STRING_SIZE], int input_fd, int output_fd)
{
    pid_t pid = fork();
    if (pid == -1)
    {
        perror("fork");
        return EXECUTION_ERROR;
    }
    else if (pid == 0)
    {
        // Child process
        // Redirect input and output to files
        dup2(input_fd, STDIN_FILENO);
        dup2(output_fd, STDOUT_FILENO);
        // Execute the file
        char *args[] = {path, NULL};
        // Execute the gcc command with arguments
        execvp(args[0], args);
        // If execl returns, it means an error occurred
        perror("execl");
        exit(EXIT_FAILURE);
    }
    // Parent process
    int status;
    struct timeval start_time;
    gettimeofday(&start_time, NULL);
    wait(&status);
    struct timeval end_time;
    gettimeofday(&end_time, NULL);
    double elapsed_time = CALCULATE_ELAPSED_TIME(start_time, end_time);
    printf("time pass %f\n", elapsed_time);
    if (elapsed_time > 5.0)
    {
        return EXECUTION_TIMED_OUT;
    }
    return EXECUTION_SUCCESSFUL;
}


int complileRunCompare(char FileToRun[MAX_STRING_SIZE], int fdCorrectOutput, int fdinputFile)
{
    // the output of the file we run
    char runOutputText[MAX_STRING_SIZE];

    //the name name for the file we comile will be called
    char outPutFileName[MAX_STRING_SIZE];
    /// TODO  to make the name an define value
    strcpy(outPutFileName, "cFileAfterCompile.out");

    

    strcpy(outPutFileName, "runOutputText.txt");
    int output_fd = open(outPutFileName, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    if (output_fd == -1)
    {
        // TODO to change the error print 
        perror("open output file");
        close(output_fd);
        return;
    }

    int grade = 0;

    compileCFile(FileToRun, outPutFileName);
    if (access(outPutFileName, F_OK) != -1)
    {
        int result=executeFileWithFDs(outPutFileName, fdinputFile, output_fd);
        //TODO to add error checking
        if(result==EXECUTION_SUCCESSFUL){
            //TODO to add text compere
        }
        else if(result==EXECUTION_TIMED_OUT){
            grade=TIMEOUT;
        }
    }
    else
    {
        grade = NO_C_FILE;
    }

    addResultToFile(grade,"defult_name");

    close(output_fd);
    unlink(outPutFileName);
    unlink(outPutFileName);
    return 0;
}

void runOverAllFolders(char studentsFolder[MAX_STRING_SIZE], int input_fd, int output_fd)
{
    DIR *dir;
    struct dirent *entry;
    struct stat file_info;

    // Open the directory
    dir = opendir(studentsFolder);
    if (dir == NULL)
    {
        printf("Error opening directory\n");
        exit(EXIT_FAILURE);
    }

    // Loop through each entry in the directory
    while ((entry = readdir(dir)) != NULL)
    {
        // Ignore the "." and ".." directories
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
        {
            continue;
        }

        // Construct the full path to the file/directory
        char path[1024];
        strcpy(path, studentsFolder);
        strcat(path, "/");
        strcat(path, entry->d_name);

        // // Get the file info for the entry
        if (stat(path, &file_info) < 0)
        {
            printf("Error getting file info for %s\n", entry->d_name);
            continue;
        }

        // Check if the entry is a directory
        if (S_ISDIR(file_info.st_mode))
        {
            // If the entry is a directory, print its name
            print_c_files(path, output_fd, input_fd);
        }
    }

    // Close the directory
    closedir(dir);
}

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    char confFile[MAX_STRING_SIZE];

    strcpy(confFile, argv[1]);

    int fdConf = open(confFile, O_RDONLY);
    if (fdConf == -1)
    {
        // todo change to perror
        printf("Error: failed to open file %s\n", confFile);
        return 1;
    }
    char buffer[MAX_STRING_SIZE * 4];
    ssize_t nread;
    nread = read(fdConf, buffer, sizeof(buffer));
    if (nread == -1)
    {
        printf("Error: failed to read from file %s\n", confFile);
        close(fdConf);
        return 1;
    }
    close(fdConf);
    // to add error TODO
    char studentsFolder[MAX_STRING_SIZE];
    char correct_outputFile[MAX_STRING_SIZE];
    char inputFile[MAX_STRING_SIZE];
    // first line
    char *token = strtok(buffer, "\n");
    strcpy(studentsFolder, token);
    // second line
    token = strtok(NULL, "\n");
    strcpy(correct_outputFile, token);
    // third line
    token = strtok(NULL, "\n");
    strcpy(inputFile, token);

    int input_fd = open(inputFile, O_RDONLY);
    if (input_fd == -1)
    {
        // TODO to change the error
        perror("open input file");
        return EXIT_FAILURE;
    }

    // run over all of the folders in the students folder
    runOverAllFolders(studentsFolder, cOutput_fd, input_fd);

    close(input_fd);
    return 0;
}
